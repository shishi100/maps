<!DOCTYPE html>
<html lang="ja">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <title>OSM + Compass Heading Arrow</title>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.7.1/dist/leaflet.css"/>
  <style>
    #map { height: 90vh; }
    #centerButton, #compassButton, #headingBadge {
      position: absolute; z-index: 1000; background: white;
      border: none; padding: 10px; font-size: 16px; cursor: pointer;
      box-shadow: 2px 2px 5px rgba(0,0,0,.3);
    }
    #centerButton { bottom: 10px; left: 10px; }
    #compassButton { bottom: 10px; left: 250px; }
    #headingBadge {
      top: 10px; right: 10px; font-size: 14px; cursor: default;
      padding: 6px 10px; border-radius: 8px;
    }
    .large-popup-text { font-size: 18px; font-weight: bold; }
  </style>
</head>
<body>
  <div id="map"></div>
  <button id="centerButton">ç¾åœ¨åœ°ã‚’åœ°å›³ä¸­å¿ƒã«è¡¨ç¤ºä¸­</button>
  <button id="compassButton">ğŸ“ ã‚³ãƒ³ãƒ‘ã‚¹æœ‰åŠ¹åŒ–</button>
  <div id="headingBadge" aria-live="polite">Heading: --Â°</div>

  <script src="https://unpkg.com/leaflet@1.7.1/dist/leaflet.js"></script>
  <script>
    // --- State ---
    let currentLat, currentLon;
    let prevLat, prevLon; // not used for compass, kept for potential fallbacks
    let currentLocationMarker;   // red circle marker
    let directionLayer;          // arrow layer
    let mapIsCentered = true;
    let compassActive = false;
    let lastHeadingDeg;          // most recent compass heading
    let headingSmoothing = null; // for low-pass smoothing

    // --- Map init ---
    const map = L.map('map').setView([35.70210389544664, 139.54364706983174], 13);
    L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', { maxZoom: 19 }).addTo(map);

    // --- Blue icon for landmarks ---
    const blueIcon = L.icon({
      iconUrl: 'https://raw.githubusercontent.com/pointhi/leaflet-color-markers/master/img/marker-icon-blue.png',
      iconSize: [25,41], iconAnchor: [12,41], popupAnchor: [1,-34],
      shadowUrl: 'https://cdnjs.cloudflare.com/ajax/libs/leaflet/1.3.4/images/marker-shadow.png',
      shadowSize: [41,41]
    });

    function addCustomMarker(lat, lon, message) {
      L.marker([lat, lon], {icon: blueIcon}).addTo(map)
        .bindPopup('<div class="large-popup-text">'+message+'</div>');
    }

    // --- Landmarks ---
    const locations = [
      { lat: 35.682384037089896, lon: 139.76607403084031, message: "1:æ±äº¬é§…ä¸¸ã®å†…åŒ—å£" },
      { lat: 35.6837847161873, lon: 139.76516997012953, message: "2:ä¼å¥å±‹æ•·è·¡" },
      { lat: 35.67983527770636, lon: 139.7647251392494, message: "3:JPã‚¿ãƒ¯ãƒ¼KITTE" },
      { lat: 35.68261914277726, lon: 139.76202206848373, message: "4:å…ƒå®®åŸå’Œç”°å€‰é–€å®ˆè¡›æ‰€" },
      { lat: 35.68011188671716, lon: 139.7583273756687, message: "5:çš‡å±…å¤–è‹‘" },
      { lat: 35.683313118612546, lon: 139.76087441655355, message: "6:å’Œç”°å€‰å™´æ°´å…¬åœ’" },
      { lat: 35.686080027980566, lon: 139.76023503838766, message: "7:å¤§æ‰‹é–€" },
      { lat: 35.68835313007799, lon: 139.75442817337603, message: "8:æ±Ÿæˆ¸åŸè·¡" },
      { lat: 35.68629221849669, lon: 139.75823291243572, message: "9:åŒå¿ƒç•ªæ‰€" },
      { lat: 35.685743225725055, lon: 139.75809342092316, message: "10:ç™¾äººç•ªæ‰€" },
      { lat: 35.6855581020504, lon: 139.75738619871785, message: "11:å¤§ç•ªæ‰€" },
      { lat: 35.68417500160364, lon: 139.7565979987103, message: "12:å¯Œå£«è¦‹æ«“" },
      { lat: 35.68540073938942, lon: 139.75555318214722, message: "13:æ¾é‡å¤§å»Šä¸‹è·¡" },
      { lat: 35.68607983062822, lon: 139.75470319161016, message: "14:å¯Œå£«è¦‹å¤šè" },
      { lat: 35.686214274376574, lon: 139.75598117204163, message: "15:æœ¬ä¸¸åºƒå ´" },
      { lat: 35.6882779269739, lon: 139.75441786573086, message: "16:å¤©å®ˆå°" },
      { lat: 35.68770815536041, lon: 139.75668232773634, message: "17:æ±è¦‹å‚" },
      { lat: 35.68764281349487, lon: 139.75806288702003, message: "18:æ­¦è”µé‡ã®é›‘æœ¨æ—ï¼ˆäºŒã®ä¸¸é›‘æœ¨æ—" },
      { lat: 35.687645886091246, lon: 139.75895814361903, message: "19:æ—¥æœ¬åº­åœ’ï¼ˆäºŒã®ä¸¸åº­åœ’ã€€ç™¾æ—¥ç´…" },
      { lat: 35.689649559287645, lon: 139.75785459570645, message: "19:å¹³å·é–€" },
      { lat: 35.68952575565945, lon: 139.7601282830361, message: "20:å’Œæ°—æ¸…éº»å‘‚åƒ" }
    ];
    locations.forEach(loc => addCustomMarker(loc.lat, loc.lon, loc.message));

    // --- Geo helpers ---
    const R = 6371000; // Earth radius (m)
    const toRad = d => d * Math.PI / 180;
    const toDeg = r => r * 180 / Math.PI;

    // Destination point given start, bearing (deg), distance (m)
    function destinationPoint(lat, lon, bearingDeg, dist) {
      const Î´ = dist / R;
      const Î¸ = toRad(bearingDeg);
      const Ï†1 = toRad(lat);
      const Î»1 = toRad(lon);

      const Ï†2 = Math.asin(Math.sin(Ï†1)*Math.cos(Î´) + Math.cos(Ï†1)*mathSinClamped(Î´)*Math.cos(Î¸));
      const Î»2 = Î»1 + Math.atan2(Math.sin(Î¸)*mathSinClamped(Î´)*Math.cos(Ï†1), Math.cos(Î´) - Math.sin(Ï†1)*Math.sin(Ï†2));
      return [toDeg(Ï†2), (toDeg(Î»2)+540)%360-180];
    }
    function mathSinClamped(x){ // protects against rare NaN at very small deltas
      const s = Math.sin(x); return Number.isFinite(s) ? s : 0;
    }

    // --- Arrow drawing using heading ---
    function updateDirectionArrowFromHeading(lat, lon, headingDeg) {
      // remove old arrow
      if (directionLayer) { map.removeLayer(directionLayer); directionLayer = null; }
      if (typeof headingDeg !== 'number' || !isFinite(headingDeg)) return;

      // arrow geometry (meters)
      const shaftLen = 25;
      const headLen  = 8;
      const headHalf = 5;

      const tip      = destinationPoint(lat, lon, headingDeg, shaftLen + headLen);
      const shaftEnd = destinationPoint(lat, lon, headingDeg, shaftLen);
      const leftBase  = destinationPoint(shaftEnd[0], shaftEnd[1], (headingDeg + 270) % 360, headHalf);
      const rightBase = destinationPoint(shaftEnd[0], shaftEnd[1], (headingDeg + 90) % 360, headHalf);

      const shaft = L.polyline([[lat, lon], shaftEnd], { weight: 4, color: 'red', opacity: 0.9 });
      const head  = L.polygon([leftBase, tip, rightBase], { color: 'red', fillColor: 'red', fillOpacity: 0.8, weight: 1 });
      directionLayer = L.layerGroup([shaft, head]).addTo(map);
    }

    // --- Geolocation ---
    function updatePosition(position) {
      currentLat = position.coords.latitude;
      currentLon = position.coords.longitude;

      if (currentLocationMarker) {
        currentLocationMarker.setLatLng([currentLat, currentLon]);
      } else {
        currentLocationMarker = L.circleMarker([currentLat, currentLon], {
          radius: 10, color: 'red', fillColor: '#f03', fillOpacity: 0.5
        }).addTo(map);
      }
      if (mapIsCentered) map.setView([currentLat, currentLon], map.getZoom());

      // If we have a heading already, update the arrow right away
      if (compassActive && typeof lastHeadingDeg === 'number') {
        updateDirectionArrowFromHeading(currentLat, currentLon, lastHeadingDeg);
      }

      prevLat = currentLat; prevLon = currentLon;
    }

    function showError(error) {
      switch (error.code) {
        case error.PERMISSION_DENIED: alert("ä½ç½®æƒ…å ±ã®åˆ©ç”¨ãŒæ‹’å¦ã•ã‚Œã¾ã—ãŸã€‚"); break;
        case error.POSITION_UNAVAILABLE: alert("ä½ç½®æƒ…å ±ã‚’å–å¾—ã§ãã¾ã›ã‚“ã€‚"); break;
        case error.TIMEOUT: alert("ä½ç½®æƒ…å ±ã®å–å¾—ãŒã‚¿ã‚¤ãƒ ã‚¢ã‚¦ãƒˆã—ã¾ã—ãŸã€‚"); break;
        default: alert("ä¸æ˜ãªã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚"); break;
      }
    }

    if (navigator.geolocation) {
      navigator.geolocation.watchPosition(updatePosition, showError, {
        enableHighAccuracy: true, maximumAge: 0, timeout: 5000
      });
    } else {
      alert("ã“ã®ãƒ–ãƒ©ã‚¦ã‚¶ã¯ä½ç½®æƒ…å ±ã«å¯¾å¿œã—ã¦ã„ã¾ã›ã‚“ã€‚");
    }

    // --- Centering toggle ---
    document.getElementById("centerButton").addEventListener("click", () => {
      mapIsCentered = !mapIsCentered;
      const btn = document.getElementById("centerButton");
      if (mapIsCentered) {
        btn.textContent = "ç¾åœ¨åœ°ã‚’åœ°å›³ä¸­å¿ƒã«è¡¨ç¤ºä¸­";
        if (currentLat !== undefined && currentLon !== undefined) {
          map.setView([currentLat, currentLon], map.getZoom());
        }
      } else {
        btn.textContent = "ç¾åœ¨åœ°ã¯è‡ªç”±ã«å‹•ã‹ã›ã¾ã™";
      }
    });

    // --- Compass / heading ---
    const headingBadge = document.getElementById('headingBadge');
    function setHeadingBadge(deg) {
      headingBadge.textContent = Number.isFinite(deg) ? `Heading: ${Math.round(deg)}Â°` : "Heading: --Â°";
    }

    // Simple low-pass filter to stabilize jittery sensors
    function smoothHeading(newDeg) {
      const alpha = 0.25; // smaller = smoother
      if (headingSmoothing == null) headingSmoothing = newDeg;
      // choose shortest angular distance
      let diff = ((newDeg - headingSmoothing + 540) % 360) - 180;
      headingSmoothing = (headingSmoothing + alpha * diff + 360) % 360;
      return headingSmoothing;
    }

    function handleOrientationEvent(event) {
      let headingDeg;

      // iOS Safari: webkitCompassHeading (0 = North, CW)
      if (typeof event.webkitCompassHeading === 'number' && isFinite(event.webkitCompassHeading)) {
        headingDeg = event.webkitCompassHeading;
      }
      // Generic absolute orientation: alpha is degrees clockwise from device's initial frame to Earth frame
      else if (event.absolute === true && typeof event.alpha === 'number' && isFinite(event.alpha)) {
        // Convert Î± to compass: 0Â° = North, CW. On many devices, compass â‰ˆ (360 - alpha)
        // Note: Screen rotation can affect this; for basic use this works well enough.
        headingDeg = (360 - event.alpha) % 360;

        // Optional: correct by screen orientation angle if available
        const screenAngle = (screen.orientation && typeof screen.orientation.angle === 'number')
          ? screen.orientation.angle : (window.orientation || 0);
        headingDeg = (headingDeg + screenAngle + 360) % 360;
      }

      if (typeof headingDeg === 'number') {
        lastHeadingDeg = smoothHeading(headingDeg);
        setHeadingBadge(lastHeadingDeg);
        if (currentLat !== undefined && currentLon !== undefined) {
          updateDirectionArrowFromHeading(currentLat, currentLon, lastHeadingDeg);
        }
      }
    }

    async function startCompass() {
      try {
        // iOS 13+ requires a user gesture + permission
        if (typeof DeviceOrientationEvent !== 'undefined' &&
            typeof DeviceOrientationEvent.requestPermission === 'function') {
          const resp = await DeviceOrientationEvent.requestPermission();
          if (resp !== 'granted') {
            alert("ã‚³ãƒ³ãƒ‘ã‚¹ã®ã‚¢ã‚¯ã‚»ã‚¹ãŒè¨±å¯ã•ã‚Œã¾ã›ã‚“ã§ã—ãŸï¼ˆè¨­å®šâ†’Safariâ†’ãƒ¢ãƒ¼ã‚·ãƒ§ãƒ³ã¨æ–¹ä½ã‚’è¨±å¯ï¼‰ã€‚");
            return;
          }
        }
        window.addEventListener('deviceorientation', handleOrientationEvent, { capture: false, passive: true });
        // Some browsers fire deviceorientationabsolute; listen to either
        window.addEventListener('deviceorientationabsolute', handleOrientationEvent, { capture: false, passive: true });
        compassActive = true;
        document.getElementById('compassButton').textContent = "ğŸ“ ã‚³ãƒ³ãƒ‘ã‚¹ç¨¼åƒä¸­";
      } catch (e) {
        console.error(e);
        alert("ã‚³ãƒ³ãƒ‘ã‚¹ã‚’åˆ©ç”¨ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚ãƒ–ãƒ©ã‚¦ã‚¶ã‚„ç«¯æœ«ã®è¨­å®šã‚’ã”ç¢ºèªãã ã•ã„ã€‚");
      }
    }

    document.getElementById('compassButton').addEventListener('click', startCompass);
  </script>
</body>
</html>
